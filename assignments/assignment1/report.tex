\documentclass[letterpaper]{article}
\synctex=1
\usepackage{graphicx}
\graphicspath{ {images/} }

\usepackage{lipsum}
\usepackage{float}

% \usepackage[
%     style=ieee,
%     backend=biber
%     ]{biblatex}
% \addbibresource{references.bib}

\usepackage{hyperref}

\usepackage{amssymb}

\usepackage{siunitx}

\usepackage{multirow}
% for merging table cells I think

\usepackage{tabularx}
\renewcommand\tabularxcolumn[1]{m{#1}}% for vertical centering text in X column
% allows for linewrap within cells
\newcolumntype{Y}{>{\centering\arraybackslash}X}

\usepackage{todonotes}
\usepackage{pdfpages}

\usepackage{fancyhdr} %header
\fancyhf{}
\fancyhead[R]{Arun Woosaree XXXXXXX}
\renewcommand\headrulewidth{0pt}
\fancyfoot[C]{\thepage}
\renewcommand\footrulewidth{0pt}
\pagestyle{fancy}

\usepackage[pdf]{graphviz}
\usepackage{adjustbox}

\usepackage{amsmath}

% make subsection use letters
\renewcommand{\thesubsection}{\alph{subsection})}

\usepackage{minted}

% \usepackage{amsthm}
\title{ECE 421 \\
Assignment 1}
\author{Arun Woosaree\\
XXXXXXX
}

%actual document
\begin{document}

\maketitle %insert titlepage here

\section{}
Functional programming is a declarative paradigm.
Computation is treated as the evaluation of mathematical functions.
Expressions and declarations are used as opposed to statements.
Given a set of inputs, the output will always be the same.
Data is immutable, and as a result,
functions have no 'side-effects'.

\section{}
\todo{Explain what it does}

Right at the beginning, we see that the program produces a side-effect, which
is using IO to output some data. This contradicts the idea of a 'purely'
functional language. However, if a program never has side effects, it would be
pretty boring. \dots \todo{say something more about side effect}

We see that the program is written in a declarative style, even though Haskell
is generally considered a purely functional language\dots


\section{}
Immutability is nice, because it makes things predictable\dots

\section{}
\begin{minted}[]{c}
void add(&int x, int y, int z){
  *x = y + z;
}
\end{minted}
\todo{idk}


\section{}

\subsection{}
\begin{itemize}
  \item sqrtx takes an input, and returns the squared value of the input
  \item imparativefun returns the sum of squares of its input, which is a list of numbers
  \item functionalfun does the same thing, but does so in a functional manner instead of an imparative way
\end{itemize}

\subsection{}
I would argue that te functionalfun is more maintainable as it's easier to
understand what the function is doing. Also, even though the functions do the
same thing, functionalfun there is less to read?? \todo{}

\subsection{}
\begin{minted}[]{fsharp}
let fourthpower x = sqrt sqrt x
\end{minted}

\section{}
\begin{itemize}
  \item changing the file system is a side effect, so it is not a pure function
  \item inserting a record -- if we're talking about a function that makes a
    database request, then it can be functional, however, if we're talking about
    the function that the database internally uses, the database would be
    updated, which means that a value is being mutated, so therefore not a pure
    function
  \item making an http call can be a pure function
  \item printing to the screen requires a side-effect, namely I/O, so it is not
    a pure function
  \item querying the DOM can be a pure function
  \item accessing the system state can be a pure function, as long as the state
    is not being mutated
  \item pure functions return the same output every time for a given set of
    inputs. Any randomness violates this, so Math.random() is not a pure
    function
\end{itemize}


\section{}
\inputminted[]{rust}{7.rs}

\section{}

\section{}
my guess is that haskell is fine with it and rustc goes REEEEEEEEEEEEEEEEEEEE
\end{document}
